---
title: "Mapping COVID-19 Data"
author: "Ryan J Buczkowski"
date: "4/4/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Initial Set-up

##### Loading packages **tidyverse** - *for data management and data processing*, **extrafont** - *fonts for text on* **ggplot2** *visualizations*, **maps** - *for built-in "map" data sets within R*, and **ggmap** - *for expanded mapping functionality in* **ggplot2**

```{r, warning=FALSE, message=FALSE}
#-------------------------------------------------------------------------------------#

#### Rudimentary Mapping of COVID-19 data geographically ####

# Ryan Buczkowski -- University of Mississippi -- Political Science Department

# 4-03-2020

#-------------------------------------------------------------------------------------#

#Loading Libraries
pacman::p_load('tidyverse', 'extrafont', 'maps', 'ggmap')
```

##### Importing data set I created from my GitHub to prepare it for mapping purposes. This dataset was created using the *John Hopkins University COVID-19 data project*, *United States Census Bureau data* from the *5-year American Community Survey* (pulled from the Census Bureau API using the **tidycensus** package), and data which was scraped from https://www.countyhealthrankings.org/ (for the number of physicians by county. All of these variables were operationalized using R and RStudio.

```{r, warning=FALSE, message=FALSE}

#Importing data from my GitHub repository
read_csv('https://raw.githubusercontent.com/buczkowskir/COVID-19_severity_index/master/healthcare_income_covid_etc.csv') -> my_data

#Looking at the data
my_data


```

##### Here is where I prepare the data to be mapped. To do this I use use a **ggplot** command (map_data()) to call the *county-level* data stored within R. This gives us a *data.frame* object with around 88000 rows across 6 variables: 

###### **lat** -- *Latitude* 
###### **long** -- *Longitude* 
###### **group** -- *Grouping Variable by County* 
###### **order** -- *Row-identifier within* **group** 
###### **region** -- *State* 
###### **subregion** -- *County*

##### Next, I turn the *data.frame* into a *tibble* object as they are less clumsy to work with. To standardize this *map-data* to **my_data** I need to change some varaible names as well as the format of the data within them. **region** and **subregion** are renamed to **state** and **county** to match the variable names within **my_data**. Within **state** and **county** the names are all in lower-case which will cause problems when joining this data with my_data. In my_data, the names of the State and County have their first leter "capitalized". To make this data match with my data I use the **str_to_title()** command within **mutate_at()**. This will put all the state and county names into the format which matches **my_data**. I then use a "mutating" join command (left_join()) join **my_data** to it. In this case, **left_join()** is appropriate because it basically makes the mapping-data the priorty dataset to match with. With all of that said, the mapping data will match by **state** and **county** with **my_data**. The end result is prepped data set with 87,949 rows across 12 variables. 

```{r}

#Mapping data
map_data(map = 'county') %>%                        #Getting built-in mapping data by county
  as_tibble() %>%                                   #Turning data.frame into a tibble
  rename('state'  = region,                         #Renaming 'region' to 'state' to match with my_data
         'county' = subregion) %>%                  #same thing with "county"
  mutate_at(vars(state, county), str_to_title) %>%  #Capitalizing correct letters of state and county names
  left_join(my_data
            
            ) -> my_data2                           #Storing prepped data in object

#Looking at prepped data
my_data2

```

# Mapping the data

##### Since I want to look at more than one state map with this data, I wrap the code for a ggplot within a function. Utilizing the filter() command I am able to set this function up in a way which makes it easy to graph whatever state that I want.

```{r, warning=FALSE, message=TRUE}

#Creating a function for the simple mapping of a few different states


state_covid_map <- function(data, state_name){
  
  data %>%
    filter(state == state_name) %>% 
    mutate(covid_per_1000 = (cases / population) * 1000) %>% 
    ggplot(aes(x = long, y = lat, group = group)) +
    geom_polygon(color = 'black', aes(fill = covid_per_1000)) +
    coord_fixed(1.3) +
    scale_fill_distiller(palette = 'YlOrRd', direction = 1, name = 'Cases Per 1000 People') +
    labs(y        = 'Latitude',
         x        = 'Longitude',
         title    = 'COVID-19 Cases by County',
         subtitle = 'Number of COVID-19 cases divided by population (in thousands) | Gray = "Missing data"',
         caption  = 'Map created using ggplot2 in RStudio \nSource: John Hopkins University \nCreator: Ryan Buczkowski - University of Mississippi - Political Science Department') +
    theme_minimal() +
    theme(axis.title      = element_text(face  = 'bold.italic',
                                         size  = 12),
          axis.text       = element_text(face  = 'bold'),
          legend.position = 'bottom',
          legend.text     = element_text(face  = 'bold.italic',
                                         size  = 8),
          legend.title    = element_text(face  = 'bold',
                                         size  = '12'),
          plot.title      = element_text(size  = 18,
                                         face  = 'bold'),
          plot.subtitle   = element_text(face  = 'italic',
                                         size  = 8),
          plot.caption    = element_text(hjust = 0,
                                         size  = 8,
                                         face  = 'italic'))
  }


```

##### After the function is created I can simply plug the name of the data set (**my_data2**) I am using into the *data* argument of the function. For the *state_name* argument of the function, I can type the name of the state inside a set of quotation marks. Below, is an example using my home state of Michigan.

```{r, message=FALSE, warning=FALSE}

state_covid_map(data = my_data2, state_name = 'Michigan')

```

##### The State where I currently live...

```{r, message=FALSE, warning=FALSE}

state_covid_map(data = my_data2, state_name = 'Mississippi')

```

##### ...and the state I am currently staying in

```{r, message=FALSE, warning=FALSE}

state_covid_map(data = my_data2, state_name = 'Arkansas')

```

### **NOTE: The colors in on the graph are only scaled in proportion to the data of the given state**

##### Finally, I wanted to see what this would look like across the United States. To do that is quite simple. Basically, we can copy and paste the code within the function I created and make a few small tweaks. After copying and pasting, I remove **filter()**, and I chance *data* to **my_data2**. For visual reasons, within **geom_polygon()** I removed the color argument as this what draws the borders of the counties. This made the map very "busy" and was therefore removed. 

```{r, message=FALSE, warning=FALSE}
  
my_data2 %>%
  mutate(covid_per_1000 = (cases / population) * 1000) %>% 
  ggplot(aes(x = long, y = lat, group = group)) +
  geom_polygon(size = .1, aes(fill = covid_per_1000)) +
  coord_fixed(1.3) +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1, name = 'Cases Per 1000 People') +
  labs(y        = 'Latitude',
       x        = 'Longitude',
       title    = 'COVID-19 Cases by County',
       subtitle = 'Number of COVID-19 cases divided by population (in thousands) | Gray = "Missing data"',
       caption  = 'Map created using ggplot2 in RStudio \nSource: John Hopkins University \nCreator: Ryan Buczkowski - University of Mississippi - Political Science Department') +
  theme_minimal() +
  theme(axis.title      = element_text(face  = 'bold.italic',
                                       size  = 12),
        axis.text       = element_text(face  = 'bold'),
        legend.position = 'bottom',
        legend.text     = element_text(face  = 'bold.italic',
                                       size  = 8),
        legend.title    = element_text(face  = 'bold',
                                       size  = '12'),
        plot.title      = element_text(size  = 18,
                                       face  = 'bold'),
        plot.subtitle   = element_text(face  = 'italic',
                                       size  = 8),
        plot.caption    = element_text(hjust = 0,
                                       size  = 8,
                                       face  = 'italic'))

```



